#!/bin/bash
# CaeliCode WSL — VS Code launcher
#
# Wrapper that finds and launches VS Code from WSL without needing
# appendWindowsPath=true (which pollutes PATH and breaks mise).
# Probes standard VS Code install locations on the Windows side.

set -euo pipefail

# Cache the resolved path for subsequent calls
CACHE_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/caelicode-vscode-path"

find_code_cli() {
    # Get the Windows user profile path (e.g. C:\Users\bertr).
    # %USERPROFILE% is more reliable than %USERNAME% because the display
    # name can differ from the profile folder name (e.g. after a rename).
    local win_profile
    win_profile="$(
        /mnt/c/Windows/System32/cmd.exe /C "echo %USERPROFILE%" 2>/dev/null | tr -d '\r'
    )" || true

    # Convert Windows path to WSL mount path (C:\Users\bertr → /mnt/c/Users/bertr)
    local wsl_profile=""
    if [ -n "${win_profile:-}" ]; then
        # Replace backslashes, convert drive letter to lowercase /mnt/<drive>/
        wsl_profile="$(echo "$win_profile" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\):|/mnt/\L\1|')"
    fi

    # Base directories to probe (user install, system install, scoop)
    local dirs=()

    if [ -n "${wsl_profile:-}" ] && [ -d "$wsl_profile" ]; then
        dirs+=(
            "${wsl_profile}/AppData/Local/Programs/Microsoft VS Code/bin"
            "${wsl_profile}/scoop/apps/vscode/current/bin"
        )
    fi

    dirs+=(
        "/mnt/c/Program Files/Microsoft VS Code/bin"
        "/mnt/c/Program Files (x86)/Microsoft VS Code/bin"
    )

    # Prefer the extensionless 'code' (a bash/shell script that VS Code
    # ships for WSL/Git Bash). Fall back to 'code.cmd' only if the bash
    # script is missing — .cmd files must be run via cmd.exe.
    for dir in "${dirs[@]}"; do
        if [ -f "${dir}/code" ]; then
            echo "${dir}/code"
            return 0
        fi
    done

    # Fallback: check for code.cmd (will need cmd.exe to execute)
    for dir in "${dirs[@]}"; do
        if [ -f "${dir}/code.cmd" ]; then
            echo "${dir}/code.cmd"
            return 0
        fi
    done

    return 1
}

# Launch VS Code, handling both bash scripts and .cmd files
run_code() {
    local path="$1"
    shift
    if [[ "$path" == *.cmd ]]; then
        # .cmd files must be executed via cmd.exe, not bash
        local win_path
        win_path="$(sed -e 's|^/mnt/\([a-z]\)/|\U\1:\\|' -e 's|/|\\|g' <<< "$path")"
        exec /mnt/c/Windows/System32/cmd.exe /C "$win_path" "$@"
    else
        exec "$path" "$@"
    fi
}

# Try cached path first
if [ -f "$CACHE_FILE" ]; then
    VSCODE_PATH="$(cat "$CACHE_FILE")"
    if [ -f "$VSCODE_PATH" ]; then
        run_code "$VSCODE_PATH" "$@"
    fi
    # Cached path is stale — remove and re-probe
    rm -f "$CACHE_FILE"
fi

# Probe for VS Code
VSCODE_PATH="$(find_code_cli)" || {
    echo "error: VS Code not found on the Windows side." >&2
    echo "" >&2
    echo "Install VS Code on Windows from: https://code.visualstudio.com" >&2
    echo "Make sure to check 'Add to PATH' during installation." >&2
    exit 1
}

# Cache the path for next time
mkdir -p "$(dirname "$CACHE_FILE")"
echo "$VSCODE_PATH" > "$CACHE_FILE"

run_code "$VSCODE_PATH" "$@"
